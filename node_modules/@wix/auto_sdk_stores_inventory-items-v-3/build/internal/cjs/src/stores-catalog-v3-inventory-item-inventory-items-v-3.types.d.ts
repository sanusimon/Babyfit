/** Inventory Item. */
export interface InventoryItem extends InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Variant ID. */
    variantId?: string;
    /** Stores location ID. */
    locationId?: string | null;
    /** Product ID. */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatus;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo;
    /**
     * Product.
     * @readonly
     */
    product?: Product;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
/** @oneof */
export interface InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
export declare enum AvailabilityStatus {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    /** Product is out of stock. */
    OUT_OF_STOCK = "OUT_OF_STOCK",
    /** Product is in stock. See `quantity` field for exact amount in stock. */
    IN_STOCK = "IN_STOCK",
    /** Product is only available for preorder. See `preorderInfo` field for more info. */
    PREORDER = "PREORDER"
}
export interface PreorderInfo {
    /**
     * Whether preorder is enabled for the product.
     *
     * Default: `false`
     */
    enabled?: boolean | null;
    /** A message the customer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /**
     * Number of products that can be preordered after stock reaches zero.
     * Supported only for inventory items with `trackQuantity = true`.
     *
     * Default: `100000`
     */
    limit?: number | null;
    /**
     * Number of times the product was preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    counter?: number | null;
    /**
     * Quantity of products that can be preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    quantity?: number | null;
}
export interface Product {
    /** Product name. */
    name?: string | null;
    /** List of category IDs that this product is included in directly. */
    directCategoryIds?: string[];
    /** Variant name. */
    variantName?: string | null;
    /** Variant SKU (stock keeping unit). */
    variantSku?: string | null;
    /** Variant visible. */
    variantVisible?: boolean | null;
}
export interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
export interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** tell us why you're invalidating the cache. You don't need to add your app name */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
export interface InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
}
export interface App {
    /** The AppDefId */
    appDefId?: string;
    /** The instance Id */
    instanceId?: string;
}
export interface Page {
    /** the msid the page is on */
    metaSiteId?: string;
    /** Invalidate by Page ID */
    pageId?: string;
}
export interface URI {
    /** the msid the URI is on */
    metaSiteId?: string;
    /** URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes */
    uriPath?: string;
}
export interface File {
    /** the msid the file is related to */
    metaSiteId?: string;
    /** Invalidate by filename (for media files such as PDFs) */
    fileName?: string;
}
export interface BulkInventoryItemAction {
    /** Inventory items. */
    inventoryItems?: InventoryItem[];
}
export interface CreateInventoryItemRequest {
    /** Inventory item to create. */
    inventoryItem: InventoryItem;
}
export interface CreateInventoryItemResponse {
    /** Created inventory item. */
    inventoryItem?: InventoryItem;
}
export interface BulkCreateInventoryItemsRequest {
    /** Inventory items to create. */
    inventoryItems: InventoryItem[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
export interface BulkCreateInventoryItemsResponse {
    /** Inventory items created by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface V3BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InventoryItem;
}
export interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface GetInventoryItemRequest {
    /** Inventory item ID. */
    inventoryItemId: string;
}
export interface GetInventoryItemResponse {
    /** Inventory item. */
    inventoryItem?: InventoryItem;
}
export interface UpdateInventoryItemRequest {
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Reason for update. */
    reason?: ReasonType;
}
/** The reason for the inventory change. */
export declare enum ReasonType {
    UNKNOWN = "UNKNOWN",
    ORDER = "ORDER",
    MANUAL = "MANUAL",
    REVERT_INVENTORY_CHANGE = "REVERT_INVENTORY_CHANGE"
}
export interface UpdateInventoryItemResponse {
    /** Updated inventory item. */
    inventoryItem?: InventoryItem;
}
/** Report when Inventory item stock status changed from in stock to out of stock and the opposite. */
export interface InventoryItemStockStatusUpdatedEvent {
    /** Inventory item new status. */
    inStock?: boolean;
}
export interface InventoryItemUpdatedWithReason {
    /** Updated inventory item. */
    currentEntity?: InventoryItem;
    /** Reason for the update. */
    reason?: ReasonType;
    /**
     * ID of the app that updated this inventory item.
     *
     * When Wix Stores updates an inventory item, value will always be: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`.
     */
    appId?: string;
}
export interface BulkUpdateInventoryItemsRequest {
    /** Inventory items to update. */
    inventoryItems: MaskedInventoryItem[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for update. */
    reason?: ReasonType;
}
export interface MaskedInventoryItem {
    /** Inventory item to update. */
    inventoryItem?: InventoryItem;
}
export interface BulkUpdateInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkUpdateInventoryItemsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
export interface SearchDetails {
    /** Defines how separate search terms in `expression` are combined. */
    mode?: Mode;
    /** Search term or expression. */
    expression?: string | null;
    /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path. */
    fields?: string[];
    /** Whether to use auto fuzzy search (allowing typos by a managed proximity algorithm). */
    fuzzy?: boolean;
}
export declare enum Mode {
    /** Any of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
export interface BulkUpdateInventoryItemsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     */
    jobId?: string;
}
export interface DeleteInventoryItemRequest {
    /** Inventory item ID. */
    inventoryItemId: string;
}
export interface DeleteInventoryItemResponse {
}
export interface BulkDeleteInventoryItemsRequest {
    /** IDs of inventory items to delete. */
    inventoryItemIds: string[];
}
export interface BulkDeleteInventoryItemsResponse {
    /** Inventory items deleted by bulk action. */
    results?: BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata;
}
export interface QueryInventoryItemsRequest {
    /** Query options. */
    query?: QueryV2;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryInventoryItemsResponse {
    /** List of inventory items. */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. */
    pagingMetadata?: PlatformPagingMetadataV2;
}
export interface PlatformPagingMetadataV2 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: CommonCursors;
}
export interface CommonCursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
export interface SearchInventoryItemsRequest {
    /** Search options. */
    search?: CursorSearch;
}
export interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * List of sort objects.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Aggregations are a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome.
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. For example, `"2023-12-20T10:52:34.795Z"`.
     */
    timeZone?: string | null;
}
/** @oneof */
export interface CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
}
export interface Aggregation extends AggregationKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation. */
    nested?: NestedAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: AggregationType;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
    /**
     * Deprecated. Use `nested` instead.
     * @deprecated Deprecated. Use `nested` instead.
     * @replacedBy kind.nested
     * @targetRemovalDate 2024-03-30
     */
    groupBy?: GroupByAggregation;
}
/** @oneof */
export interface AggregationKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation. */
    nested?: NestedAggregation;
}
export interface RangeBucket {
    /** Inclusive lower bound of the range. Required if `to` is not provided. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if `from` is not provided. */
    to?: number | null;
}
export declare enum SortType {
    /** Sort by number of matches. */
    COUNT = "COUNT",
    /** Sort by value of the field alphabetically. */
    VALUE = "VALUE"
}
export declare enum SortDirection {
    /** Sort in descending order. */
    DESC = "DESC",
    /** Sort in ascending order. */
    ASC = "ASC"
}
export declare enum MissingValues {
    /** Exclude missing values from the aggregation results. */
    EXCLUDE = "EXCLUDE",
    /** Include missing values in the aggregation results. */
    INCLUDE = "INCLUDE"
}
export interface IncludeMissingValuesOptions {
    /** Specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
    addToBucket?: string;
}
export declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values. */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value. */
    MIN = "MIN",
    /** Maximum value. */
    MAX = "MAX"
}
export interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions;
    /** Whether to sort by number of matches or value of the field. */
    sortType?: SortType;
    /** Whether to sort in ascending or descending order. */
    sortDirection?: SortDirection;
    /** How many aggregations to return. Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Whether to include or exclude missing values from the aggregation results. Default: `EXCLUDE`. */
    missingValues?: MissingValues;
}
/** @oneof */
export interface ValueAggregationOptionsOneOf {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions;
}
export declare enum NestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
export interface RangeAggregation {
    /** List of range buckets, where during aggregation each entity will be placed in the first bucket its value falls into, based on the provided range bounds. */
    buckets?: RangeBucket[];
}
export interface ScalarAggregation {
    /** Define the operator for the scalar aggregation. */
    type?: ScalarType;
}
export interface DateHistogramAggregation {
    /** Interval for date histogram aggregation. */
    interval?: Interval;
}
export declare enum Interval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
export interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: NestedAggregationType;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
}
/** @oneof */
export interface NestedAggregationItemKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
}
export declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one. */
    NESTED = "NESTED"
}
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one. */
export interface NestedAggregation {
    /** Flattened list of aggregations, where each next aggregation is nested within previous one. */
    nestedAggregations?: NestedAggregationItem[];
}
export interface GroupByAggregation extends GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Field to aggregate by. */
    fieldPath?: string;
}
/** @oneof */
export interface GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
}
export interface SearchInventoryItemsResponse {
    /** List of inventory items. */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
    /** Aggregation data. */
    aggregationData?: AggregationData;
}
export interface CursorPagingMetadata {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
export interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
export interface AggregationData {
    /** key = aggregation name (as derived from search request). */
    results?: AggregationResults[];
}
export interface ValueAggregationResult {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number;
}
export interface RangeAggregationResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number;
}
export interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** User-defined name of aggregation, matches the one provided in request. */
    name?: string;
    /** Type of aggregation that matches result. */
    type?: AggregationType;
    /** Field to aggregate by, matches the one provided in request. */
    fieldPath?: string;
}
/** @oneof */
export interface NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
}
export interface ValueResults {
    /** List of value aggregations. */
    results?: ValueAggregationResult[];
}
export interface RangeResults {
    /** List of ranges returned in same order as requested. */
    results?: RangeAggregationResult[];
}
export interface AggregationResultsScalarResult {
    /** Type of scalar aggregation. */
    type?: ScalarType;
    /** Value of the scalar aggregation. */
    value?: number;
}
export interface NestedValueAggregationResult {
    /** Value of the field. */
    value?: string;
    /** Nested aggregations. */
    nestedResults?: NestedAggregationResults;
}
export interface ValueResult {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number | null;
}
export interface RangeResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number | null;
}
export interface ScalarResult {
    /** Value of the scalar aggregation. */
    value?: number;
}
export interface NestedResultValue extends NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
/** @oneof */
export interface NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
export interface Results {
    /** List of nested aggregations. */
    results?: Record<string, NestedResultValue>;
}
export interface DateHistogramResult {
    /** Date in ISO 8601 format. */
    value?: string;
    /** Count of documents in the bucket. */
    count?: number;
}
export interface GroupByValueResults {
    /** List of value aggregations. */
    results?: NestedValueAggregationResult[];
}
export interface DateHistogramResults {
    /** List of date histogram aggregations. */
    results?: DateHistogramResult[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form.
 * Aggregations in resulting array are keyed by requested aggregation `name`.
 */
export interface NestedResults {
    /** List of nested aggregations. */
    results?: Results[];
}
export interface AggregationResults extends AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
    /** User-defined name of aggregation as derived from search request. */
    name?: string;
    /** Type of aggregation that must match provided kind as derived from search request. */
    type?: AggregationType;
    /** Field to aggregate by as derived from search request. */
    fieldPath?: string;
}
/** @oneof */
export interface AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
}
export interface SearchInventoryItemsWithOffsetRequest {
    /** WQL expression. */
    search?: OffsetSearch;
}
export interface OffsetSearch extends OffsetSearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can't be used together with 'cursor_paging'. */
    paging?: Paging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Projection on the result object - list of specific field names to return. If fieldsets are also specified, return the union of fieldsets and fields. */
    fields?: string[];
    /** Projection on the result object - list of named projections. For example, "basic" will return ID and name fields. Specifying multiple fieldsets will return the union of fields from all. Specifying fieldsets and fields will also return the union of fields. */
    fieldsets?: string[];
    /** Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome.
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. For example, `"2023-12-20T10:52:34.795Z"`.
     */
    timeZone?: string | null;
}
/** @oneof */
export interface OffsetSearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can't be used together with 'cursor_paging'. */
    paging?: Paging;
}
export interface SearchInventoryItemsWithOffsetResponse {
    /** InventoryItems which satisfy the provided query. */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. Contains cursor which can be used in next query. */
    pagingMetadata?: PagingMetadata;
}
export interface PagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
}
export interface BulkDecrementInventoryItemsRequest {
    /** Inventory item IDs and decrement data. */
    decrementData: DecrementDataById[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
export interface DecrementDataById {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
export interface BulkDecrementInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkIncrementInventoryItemsRequest {
    /** Inventory item IDs and increment data. */
    incrementData: IncrementDataById[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}
export interface IncrementDataById {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to increment by. */
    incrementBy?: number;
}
export interface BulkIncrementInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkDecrementInventoryItemsByVariantAndLocationRequest {
    /** Variant and location IDs, as well as decrement data. */
    decrementData: DecrementDataByVariantAndLocation[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
export interface DecrementDataByVariantAndLocation {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
export interface BulkDecrementInventoryItemsByVariantAndLocationResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkIncrementInventoryItemsByVariantAndLocationRequest {
    /** Variant and location IDs, as well as increment data. */
    incrementData: IncrementDataByVariantAndLocation[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}
export interface IncrementDataByVariantAndLocation {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to increment by. */
    incrementBy?: number;
}
export interface BulkIncrementInventoryItemsByVariantAndLocationResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata details as: totalSuccess and totalFailure. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
export interface Empty {
}
export interface BulkSetOrAdjustInventoryItemsByFilterRequest {
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter: Record<string, any> | null;
    /** Action to adjust the inventory by. (e.g increment or decrement) */
    adjustedInventoryAction: AdjustInventoryAction;
    /** Free text to match in searchable fields */
    search?: SearchDetails;
}
export interface AdjustInventoryAction extends AdjustInventoryActionActionOneOf {
    /** Amount to increment by. */
    incrementBy?: number;
    /** Amount to decrement by. */
    decrementBy?: number;
}
/** @oneof */
export interface AdjustInventoryActionActionOneOf {
    /** Amount to increment by. */
    incrementBy?: number;
    /** Amount to decrement by. */
    decrementBy?: number;
}
export interface BulkSetOrAdjustInventoryItemsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     */
    jobId?: string;
}
export interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface ProductNonNullableFields {
    directCategoryIds: string[];
}
interface InventoryItemNonNullableFields {
    inStock: boolean;
    quantity: number;
    variantId: string;
    productId: string;
    trackQuantity: boolean;
    availabilityStatus: AvailabilityStatus;
    product?: ProductNonNullableFields;
}
export interface CreateInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface V3BulkInventoryItemResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: InventoryItemNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
export interface BulkCreateInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface GetInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields;
}
export interface UpdateInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields;
}
export interface BulkUpdateInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface BulkUpdateInventoryItemsByFilterResponseNonNullableFields {
    jobId: string;
}
interface BulkInventoryItemResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
}
export interface BulkDeleteInventoryItemsResponseNonNullableFields {
    results: BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface QueryInventoryItemsResponseNonNullableFields {
    inventoryItems: InventoryItemNonNullableFields[];
}
interface ValueAggregationResultNonNullableFields {
    value: string;
    count: number;
}
interface ValueResultsNonNullableFields {
    results: ValueAggregationResultNonNullableFields[];
}
interface RangeAggregationResultNonNullableFields {
    count: number;
}
interface RangeResultsNonNullableFields {
    results: RangeAggregationResultNonNullableFields[];
}
interface AggregationResultsScalarResultNonNullableFields {
    type: ScalarType;
    value: number;
}
interface NestedAggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface NestedValueAggregationResultNonNullableFields {
    value: string;
    nestedResults?: NestedAggregationResultsNonNullableFields;
}
interface GroupByValueResultsNonNullableFields {
    results: NestedValueAggregationResultNonNullableFields[];
}
interface DateHistogramResultNonNullableFields {
    value: string;
    count: number;
}
interface DateHistogramResultsNonNullableFields {
    results: DateHistogramResultNonNullableFields[];
}
interface AggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    groupedByValue?: GroupByValueResultsNonNullableFields;
    dateHistogram?: DateHistogramResultsNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface AggregationDataNonNullableFields {
    results: AggregationResultsNonNullableFields[];
}
export interface SearchInventoryItemsResponseNonNullableFields {
    inventoryItems: InventoryItemNonNullableFields[];
    aggregationData?: AggregationDataNonNullableFields;
}
export interface BulkDecrementInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface BulkIncrementInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface BulkSetOrAdjustInventoryItemsByFilterResponseNonNullableFields {
    jobId: string;
}
export {};
